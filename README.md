# Подсчёт суммы элементов массива

Задача: реализуйте подсчёт суммы элементов массива несколькими потоками.

        Массив случайных чисел размером N должен разбиваться на M равных частей (M < N), каждая из которых выполняется в отдельном потоке.
        Каждый поток вычисляет сумму элементов своей части.
        По завершении выполнения потоков, вычисляется общая сумма массива.

Входные переменные:

  N — размер массива;

  M — количество частей, на которые будет разбит массив.

Результат: сумма элементов массива.


Пожелания к выполнению задания

1. Используйте в решении принципы ООП, учитывайте производительность программы.

2. Выполните анализ результата работы программы. Для этого предлагаем вам сравнить время вычисления итоговой суммы элементов массива с использованием нескольких потоков и время подсчёта суммы элементов массива в основном потоке (без разбиения на части).

Запустите программу, например, с 1, 4, 8, 10 потоками. Размер массива можно указать 100 тысяч, 1 миллион, 10 миллионов элементов. Укажите в ответе количество ядер вашего процессора.


Для решения задачи с использованием принципов ООП и анализа производительности программы, 
мы создадим класс ArraySumCalculator, 
который будет отвечать за разбиение массива на части, 
вычисление суммы в нескольких потоках и измерение времени выполнения. 
Затем сравним время выполнения с использованием разного количества потоков и в одном потоке.


Объяснение кода:

    Класс ArraySumCalculator:

        Инкапсулирует логику разбиения массива, вычисления суммы и измерения времени.

        Метод calculateParallelSum вычисляет сумму с использованием нескольких потоков.

        Метод calculateSingleThreadSum вычисляет сумму в одном потоке.

    Разбиение массива:

        Метод splitArray делит массив на части для каждого потока.

    Вычисление суммы:

        Метод calculateSum вычисляет сумму элементов части массива.

    Измерение времени:

        Используется std::chrono::high_resolution_clock для точного измерения времени выполнения.

    Заполнение массива случайными числами:

        Массив заполняется случайными числами от 1 до 100.

    Количество ядер процессора:

        Используется std::thread::hardware_concurrency() для определения количества ядер.

Пример вывода:
Copy

Количество ядер процессора: 8
Время выполнения с 1 потоками: 0.012345 секунд
Сумма: 50498234
Время выполнения с 4 потоками: 0.003456 секунд
Сумма: 50498234
Время выполнения с 8 потоками: 0.002345 секунд
Сумма: 50498234
Время выполнения с 10 потоками: 0.002567 секунд
Сумма: 50498234
Время выполнения в одном потоке: 0.011234 секунд
Сумма в одном потоке: 50498234

Анализ результатов:

    Зависимость времени от количества потоков:

        С увеличением количества потоков время выполнения уменьшается, но только до определённого предела (количества ядер процессора).

        При использовании большего количества потоков, чем ядер, время может увеличиться из-за накладных расходов на переключение между потоками.

    Сравнение с одним потоком:

        Многопоточное выполнение значительно быстрее для больших массивов.

        Для маленьких массивов накладные расходы на создание потоков могут превысить выгоду от параллелизма.

    Оптимальное количество потоков:

        Оптимальное количество потоков обычно равно количеству ядер процессора.

Рекомендации:

    Для максимальной производительности используйте количество потоков, равное количеству ядер процессора.

    Для маленьких массивов (например, менее 1000 элементов) многопоточность может быть неэффективной.

    Убедитесь, что размер массива достаточно большой, чтобы многопоточность дала заметный прирост производительности.

Количество ядер процессора:

Количество ядер процессора можно узнать с помощью std::thread::hardware_concurrency(). Например, если у вас 8-ядерный процессор, 
то оптимальное количество потоков будет 8.
